# Building a Python Service Node

In this exercise, we will fill in the appropriate pieces of code to build a perception pipeline. The end goal will be to broadcast a transform with the pose information of the object of interest.


# Prepare New Workspace:

We will create a new catkin workspace, since this exercise does not overlap with the previous PlanNScan exercises.

1. Disable automatic sourcing of your previous catkin workspace:
    1. <code>gedit ~/.bashrc</code>
    2. comment out <code>#</code> the last line, sourcing your <code>~/catkin_ws/devel/setup.bash</code>

# Intro (Review Existing Code)

Most of the infrastructure for a ros node has already been completed for you; the focus of this exercise is the perception algorithms/pipleline. The <code>CMakelists.txt</code> and <code>package.xml</code> are complete and an executable has been provided. You could run the executable as is, but you would get errors. At this time we will explore the source code that has been provided - browse the provided <code>perception_node.cpp</code> file. This tutorial is a rehash of training <a href="Exercise 5.1 Building a Perception Pipeline" target="http://ros-industrial.github.io/industrial_training/_source/session5/Building-a-Perception-Pipeline.html">Exercise 5.1 Building a Perception Pipeline</a> and as such the C++ code has already been set up.  If something does not make sense, revisit that exercise.  Open up the preception_node.cpp file and look over the filtering functions.

## *Need to clarify where to get the finished package with perception_node.cpp and build files

# Create a Python node

Now that we have converted several filters to C++ functions, we are ready to call it from a Python node.  If you have not done so already, install PyCharm, community edition.  This IDE has the necessary parser for editing, without it, you will not be able to review any syntax issues in QT. *__Are we sure we need Pycharm? Errors will still just show when the node is run, and there are no real instructions for how to use PyCharm in this tutorial__

1.	Create a new package inside your perception_ws. In the terminal, change the directory to your src folder:

        cd ~/perception_ws/src/
        catkin_create_pkg filter_call rospy roscpp perception_msgs

    *__"catkin_create_pkg" instead of "catkin create pkg"? the tutorials use the latter for the entirety of the tutorials. The equivalent command would be "catkin create pkg filter_call --catkin-deps rospy roscpp perception_msgs"__

2.	Check that your package was created:

        ls

     *__Not sure where this really fits in or what it means__ We will not be using ‘perception_msgs’ as we will not be creating custom messages in this course.  It is included for further student knowledge. If you wish for a more in depth explanation including how to implement customer messages, here is a good <a href="MIT resource" target="http://duckietown.mit.edu/media/pdfs/1rpRisFoCYUm0XT78j-nAYidlh-cDtLCdEbIaBCnx9ew.pdf">MIT resource</a> on the steps taken

    *__Why are we including perception msgs if we are not using them? We should need rospy, lesson_perception, and maybe roscpp for this then. The original package creation command may need adjusting. It says "It is included for further student knowledge"- what is? I don't understand__

3.	Open *CMakeLists.txt*. You can open the file in Pycharm or QT (or you can use nano, emacs, vim, or sublime). Uncomment line 23, and save.

        catkin_python_setup()


# <big>Creating setup.py</big>

The <code>setup.py</code> file makes your python module available to the entire workspace and subsequent packages.  By default, this isn’t created by the <code>catkin_create_pkg</code> command. *__Update if changed to "catkin create pkg" earlier__

1.	In your terminal type

        nano filter_call/setup.py

2.	Copy and paste the following to the setup.py file (to paste into a terminal, Ctrl+Shift+V)

        ## ! DO NOT MANUALLY INVOKE THIS setup.py, USE CATKIN INSTEAD
        from distutils.core import setup
        from catkin_pkg.python_setup import generate_distutils_setup
        # fetch values from package.xml
        setup_args = generate_distutils_setup(
        packages=['<package_name>'],
        package_dir={'': 'include'},
        )
        setup(**setup_args)


Change <code>packages = [ . . . ],</code> to your list of strings of the name of the folders inside your *include* folder.  By convention, this will be the same name as the package <code>'filter_call'</code> . The configures ‘filter_call’/include/filter_call as a python module available to the whole workspace. *__This final statement doesn't quite make sense. What is 'filter_call'/include/filter_call?__

3.	Save and close the file.

In order for this folder to be treated as a python module, the <code>\__init__.py</code> file must exist.

4.	Create one in the terminal by typing:

        touch filter_call/include/filter_call/__init__.py

5.	Now we are ready to start developing the client node to call our C++ service.  Create a service called ‘FilterCloud.srv’ in the lesson_perception package as outlined in Section 2.0, updating the <code>CMakeLists.txt</code> and the <code>package.xml</code> file respectively.  Copy and paste the following into the file.


        #request
        sensor_msgs/PointCloud2 input_cloud
        string topic
        string pcdfilename
        
        # Removes objects outside a defined grid pattern x,y,z
        byte VOXELGRID=0
        
        # Removes the objects based on volume of space
        byte PASSTHROUGH=1
        
        # Issolate objects located along the largest flat surface (floor)
        byte PLANESEGMENTATION=2
        
        # Determine clusters based on pcd density to identify multiple objects
        byte CLUSTEREXTRACTION=3
        
        # Operation to be performed
        byte operation
        
        ---
        #response
        sensor_msgs/PointCloud2 output_cloud
        bool success


# Publishing the Point Cloud


As iterated before, we are creating a ROS C++ node to publish the point cloud and then have a Python node listen and call filtering operations, resulting in a new, aggregated point cloud.  Let’s start with modifying our C++ code to publish in a manner supportive to python. Remember, the C++ code is already done so all you need to do is write your python script and view the results in rviz.

*__This paragraph may need rewriting. Publishing and listening are more akin to topics and messages, not services like is being used in this example. Also the modifications to the C++ code isn't as much about making it compatible with python as just making it respond to service requests, whether from a python or c++ node__

# <big>Implement a Voxel Filter</big>

1.	In *perception_node.cpp*, uncomment the boolean function called <code>filterCallBack</code> (just above <code>main</code>) which performs in the service. This will be the service used by the python client to run subsequent filtering operations.


        bool filterCallback(lesson_perception::FilterCloud::Request& request,
                            lesson_perception::FilterCloud::Response& response)
        {
          pcl::PointCloud<pcl::PointXYZ>::Ptr cloud (new pcl::PointCloud<pcl::PointXYZ>);
          pcl::PointCloud<pcl::PointXYZ>::Ptr filtered_cloud (new pcl::PointCloud<pcl::PointXYZ>);
        
          switch (request.operation)
          {
        
            case lesson_perception::FilterCloud::Request::VOXELGRID :
            {
              filtered_cloud = voxelGrid(cloud, 0.01);
              break;
            }
        
            default :
            {
              ROS_ERROR("no point cloud found");
              return false;
            }
        
          }
        
        /*
         * SETUP PUBLISHERS
         */
          pcl::toROSMsg(*filtered_cloud, response.output_cloud);
          response.output_cloud.header=request.input_cloud.header;
          response.output_cloud.header.frame_id="kinect_link";
          response.success = true;
          return true;
        
        }
        
    *__The SETUP PUBLISHERS block should probably be changed to something more like WRITE RESPONSE. This section is not setting up any publihser__

2. Now that we have the framework for the filtering, open your terminal. Make sure you are in the filter_call directory. Create a *scripts* folder.

        mkdir scripts

3. Open Qt and right click on the folder, create a new python project.  Call it *filter_call.py*

    *__Python file, not project? Or blank file? Qt automatically populates two lines at the top if you press new python file:__

        #!/usr/bin/env python
        # -*- coding: utf-8 -*-

    __Also, are we supposed to be using Qt or PyCharm?__

4. Copy and paste the following code in *filter_call.py* to import necessary libraries:

        #!/usr/bin/env python
        
        import rospy
        import lesson_perception.srv
        from sensor_msgs.msg import PointCloud2

5. We will create an <code>if</code> statement to run our python node when this file is executed. Initalize as follows:


        if __name__ == '__main__':
            try:
            except rospy.ROSInterruptException:
                print("Service call failed: %s")
                pass


6. Include a <code>rospy.spin()</code> in the <code>try</code> block to look like the following:

        if __name__ == '__main__':
            try:
                rospy.spin()
            except rospy.ROSInterruptException as e:
                print("Service call failed: %s" % str(e))
                pass


    *__Why include a step just to add a rospy.spin()? Seems like the last two steps could reasonably be combined. Also, why are we including a spin at all if our node only runs through once, calling the filter service and publishing the result?__

7. Copy and paste the following inside the <code>try</code> block:


        srvp = rospy.ServiceProxy('filter_cloud', lesson_perception.srv.FilterCloud)
        req = lesson_perception.srv.FilterCloudRequest()
        req.pcdfilename = rospy.get_param('~pcdfilename', '')
        req.operation = 0
        # FROM THE SERVICE, ASSIGN POINTS
        req.input_cloud = PointCloud2()

        # ERROR HANDLING
        if req.pcdfilename == '':
            print('no file found')
            raise Exception('no file found')

        # PACKAGE THE FILTERED POINTCLOUD2 TO BE PUBLISHED
        res_voxel = srvp(req)
        print('response received')
        if res_voxel.success == False:
            res_voxel.success = True
            raise Exception('execution not valid')

        # PUBLISH VOXEL FILTERED POINTCLOUD2
        pub = rospy.Publisher('/perception_voxelGrid', PointCloud2, queue_size=10, latch=True)
        pub.publish(res_voxel.output_cloud)
        print("published: voxel grid filter response")
        rate = rospy.Rate(10)

    *__Note that the error handling does not actually do anything. It will always evaluate to false because you are just checking if two different string constants are the same__

8. Paste the following lines above the <code>try</code> block (still within the <code>if</code> statement to initialize the python node and wait for the C++ node's service.

        rospy.init_node('filter_cloud', anonymous=True)
        rospy.wait_for_service('filter_cloud')

# <big>Viewing Results</big>

1. In your terminal, run

        roscore

2. Source a new terminal and run the C++ filter service node

        rosrun lesson_perception perception_node

3. Source a new terminal and run the python service caller node

        rosrun filter_call listener _pcdfilename:="/me/ros-industrial/catkin_ws/table.pcd"
        
    *__The node is filter_call.py. listener was never mentioned until this point. And listener is again not the best terminology when referring to service calls__    
        
    *__The file in the previous command in general is not correect. If coming from the last tutorial, it is ~/table.pcd. If someone is coming straight here, they need some instructions on downloading the file and placing it somewhere__

4. Source a new terminal and run rviz

        rosrun rviz rviz

5. Add a new PointCloud2

6. Change the fixed frame to kinect_link

    You may need to uncheck and recheck the PointCloud2.

    # *__At this point in time the combination of command listed here and the code do not work.__*

# Implement Pass-Through Filters

1. In *perception_node.cpp* in the <code>lesson_perception</code> package, within <code>main</code>, uncomment these two lines.

<pre><code>
  priv_nh_.param<double>("passThrough_max", passThrough_max_, 1.0f);
  priv_nh_.param<double>("passThrough_min", passThrough_min_, -1.0f);</code></pre>


2. Update the switch to look as shown below:


        switch (request.operation)
        {
        
        case lesson_perception::FilterCloud::Request::VOXELGRID :
        {
          filtered_cloud = voxelGrid(cloud, 0.01);
          break;
        }
        
        case lesson_perception::FilterCloud::Request::PASSTHROUGH :
        {
          filtered_cloud = passThrough(cloud);
          break;
        }
        default :
        {
          ROS_ERROR("no point cloud found");
          return false;
        }
        
        }


    However, because we can pass the file as two types, we need to check that there is even data so above the switch inside the <code>filterCallback()</code> function, add the following code above the switch statement:


        if (request.pcdfilename.empty())
        {
          pcl::fromROSMsg(request.input_cloud, *cloud);
          ROS_INFO_STREAM("cloud size: " << cloud->size());
        }
        else
        {
          pcl::io::loadPCDFile(request.pcdfilename, *cloud);
        }
        
        if (cloud->empty())
        {
          ROS_ERROR("input cloud empty");
          response.success = false;
          return false;
        }
        

    This checks for data based on both service types.

    *__What do you mean by both service types? Also, I believe that this code should have been added at least before we tried testing out the node earlier__

3. Add variable declarations at the top of the program and uncomment the pcl header similar to the voxel filter.

4. Save and build


    # <big>Edit the Python Code</big>


5. Open the python node and copy paste the following code after the voxel grid, before the <code>rospy.spin()</code>.  Keep care to maintain indents:


        srvp = rospy.ServiceProxy('filter_cloud', lesson_perception.srv.FilterCloud)
        req = lesson_perception.srv.FilterCloudRequest()
        req.pcdfilename = ''
        req.operation = 1
        # FROM THE SERVICE, ASSIGN POINTS
        req.input_cloud = res_voxel.output_cloud
        
        # ERROR HANDLING
        if '.pcdfilename' == '':
            print('no file found')
            raise Exception('no file found')
        
        # PACKAGE THE FILTERED POINTCLOUD2 TO BE PUBLISHED
        res_pass = srvp(req)
        print('response received')
        if res_pass.success == False:
            res_pass.success = True
            raise Exception('execution not valid')
        
        # PUBLISH PASSTHROUGH FILTERED POINTCLOUD2
        pub = rospy.Publisher('/perception_passThrough', PointCloud2, queue_size=10, latch=True)
        pub.publish(res_pass.output_cloud)
        print("published: pass through filter response")
        rate = rospy.Rate(10)


7. Save and run from the terminal

    Within Rviz, compare PointCloud2 displays based on the /kinect/depth_registered/points (original camera data) and object_cluster (latest processing step) topics. Part of the original point cloud has been “clipped” out of the latest processing result.

    When you are satisfied with the pass-through filter results, press Ctrl+C to kill the node. There is no need to close or kill the other terminals/nodes.


# Plane Segmentation

This method is one of the most useful for any application where the object is on a flat surface. In order to isolate the objects on a table, you perform a plane fit to the points, which finds the points which comprise the table, and then subtract those points so that you are left with only points corresponding to the object(s) above the table. This is the most complicated PCL method we will be using and it is actually a combination of two: the RANSAC segmentation model, and the extract indices tool. An in depth example can be found on the <a href="PCL Plane Model Segmentation Tutorial" target="http://pointclouds.org/documentation/tutorials/planar_segmentation.php#planar-segmentation">PCL Plane Model Segmentation Tutorial</a>; otherwise you can copy the below code snippet.


1. In the <code>main():</code> uncomment

        priv_nh_.param<double>("maxIterations", maxIterations_, 200.0f);
        priv_nh_.param<double>("distThreshold", distThreshold_, 0.01f);

    *__In general, it doesn't make sense to be uncommenting these as we go if we don't actually use the parameters__

2. Update the switch to look as shown below:

        switch (request.operation)
        {
        
          case lesson_perception::FilterCloud::Request::VOXELGRID :
          {
            filtered_cloud = voxelGrid(cloud, 0.01);
            break;
          }
        
          case lesson_perception::FilterCloud::Request::PASSTHROUGH :
          {
            filtered_cloud = passThrough(cloud);
            break;
          }
          case lesson_perception::FilterCloud::Request::PLANESEGMENTATION :
          {
            filtered_cloud = planeSegmentation(cloud);
            break;
          }
          default :
          {
            ROS_ERROR("no point cloud found");
            return false;
          }
        
        }


3. Add variable declarations at the top up the program and uncomment the pcl header.

    *__what do you mean by this?__

4. Save and build

    # <big>Edit the Python Code</big>

5. Open the python node and copy paste the following code after the pass through, before the <code>rospy.spin()</code>.  Keep care to maintain indents:


        srvp = rospy.ServiceProxy('filter_cloud', lesson_perception.srv.FilterCloud)
        req = lesson_perception.srv.FilterCloudRequest()
        req.pcdfilename = ''
        req.operation = 2
        # FROM THE SERVICE, ASSIGN POINTS
        req.input_cloud = res_pass.output_cloud
        
        # ERROR HANDLING
        if '.pcdfilename' == '':
            print('no file found')
            raise Exception('no file found')
        
        # PACKAGE THE FILTERED POINTCLOUD2 TO BE PUBLISHED
        res_seg = srvp(req)
        print('response received')
        if res_seg.success == False:
            res_seg.success = True
            raise Exception('execution not valid')
        
        # PUBLISH PLANESEGMENTATION FILTERED POINTCLOUD2
        pub = rospy.Publisher('/perception_planeSegmentation', PointCloud2, queue_size=10, latch=True)
        pub.publish(res_seg.output_cloud)
        print("published: plane segmentation filter response")
        rate = rospy.Rate(10)


6. Save and run the previous commands for viewing in terminals

    Within Rviz, compare PointCloud2 displays based on the /kinect/depth_registered/points (original camera data) and object_cluster (latest processing step) topics. Only points lying above the table plane remain in the latest processing result.

    1. When you are done viewing the results you can go back and change the ”setMaxIterations” and “setDistanceThreshold” values to control how tightly the plane-fit classifies data as inliers/outliers, and view the results again. Try using values of <code>MaxIterations=100</code> and <code>DistanceThreshold=0.010</code>

    2. When you are satisfied with the plane segmentation results, use Ctrl+C to kill the node. There is no need to close or kill the other terminals/nodes.



# Euclidian Cluster Extraction

This method is useful for any application where there are multiple objects. This is also a complicated PCL method. An in depth example can be found on the <a href="PCL Euclidean Cluster Extration Tutorial" target="http://pointclouds.org/documentation/tutorials/cluster_extraction.php#cluster-extraction">PCL Euclidean Cluster Extration Tutorial</a>.


1. In <code>main</code> uncomment


        priv_nh_.param<double>("clustTol", clustTol_, 0.01f);
        priv_nh_.param<double>("clustMax", clustMax_, 10000.0);
        priv_nh_.param<double>("clustMin", clustMin_, 300.0f);
  
    *__Again, doesn't seem to be relevant or used in the tutorial__


2. Update the switch to look as shown below:


        switch (request.operation)
        {
        
          case lesson_perception::FilterCloud::Request::VOXELGRID :
          {
            filtered_cloud = voxelGrid(cloud, 0.01);
            break;
          }
        
          case lesson_perception::FilterCloud::Request::PASSTHROUGH :
          {
            filtered_cloud = passThrough(cloud);
            break;
          }
          case lesson_perception::FilterCloud::Request::PLANESEGMENTATION :
          {
            filtered_cloud = planeSegmentation(cloud);
            break;
          }
          case lesson_perception::FilterCloud::Request::CLUSTEREXTRACTION :
          {
            std::vector<pcl::PointCloud<pcl::PointXYZ>::Ptr> temp =clusterExtraction(cloud);
            if (temp.size()>0)
            {
              filtered_cloud = temp[0];
            }
            //filtered_cloud = clusterExtraction(cloud)[0];
            break;
          }
          default :
          {
            ROS_ERROR("no point cloud found");
            return false;
          }
        
        }

    *__Should that commented out bit be in there?__*
     
    *__//filtered_cloud = clusterExtraction(cloud)[0];__*

3. Add variable declarations at the top up the program and uncomment the pcl header.

    *__Again, what do you mean?__

4. Save and build


# <big>Edit the Python Code</big>


5. Open the python node and copy paste the following code after plane segmentation, before the <code>rospy.spin()</code>.  Keep care to maintain indents:


        srvp = rospy.ServiceProxy('filter_cloud', lesson_perception.srv.FilterCloud)
        req = lesson_perception.srv.FilterCloudRequest()
        req.pcdfilename = ''
        req.operation = 3
        # FROM THE SERVICE, ASSIGN POINTS
        req.input_cloud = res_seg.output_cloud

        # ERROR HANDLING
        if '.pcdfilename' == '':
            print('no file found')
            raise Exception('no file found')

        # PACKAGE THE FILTERED POINTCLOUD2 TO BE PUBLISHED
        res_cluster = srvp(req)
        print('response received')
        if res_cluster.success == False:
            res_cluster.success = True
            raise Exception('execution not valid')

        # PUBLISH CLUSTEREXTRACTION FILTERED POINTCLOUD2
        pub = rospy.Publisher('/perception_clusterExtraction', PointCloud2, queue_size=10, latch=True)
        pub.publish(res_cluster.output_cloud)
        print("published: cluster extraction filter response")
        rate = rospy.Rate(10)


6. Save and run from the terminal

    1. When you are satisfied with the cluster extraction results, use Ctrl+C to kill the node. There is no need to close or kill the other terminals/nodes.


# Future Study

The student is encouraged to convert <a href="Exercise 5.1" target="http://ros-industrial.github.io/industrial_training/_source/session5/Building-a-Perception-Pipeline.html">Exercise 5.1</a> into callable functions and further refine the filtering operations.

Futher, for simplicity the python code was repeated for each filtering instance, the student is encouraged to create a function to handle the publishing.




































